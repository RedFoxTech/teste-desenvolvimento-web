import { EMPTY, fromEvent, of, race, Subject, timer } from 'rxjs';
import { endWith, filter, takeUntil } from 'rxjs/operators';
import { getTransitionDurationMs } from './util';
import { environment } from '../../environment';
import { runInZone } from '../util';
const noopFn = () => { };
const ɵ0 = noopFn;
const { transitionTimerDelayMs } = environment;
const runningTransitions = new Map();
export const ngbRunTransition = (zone, element, startFn, options) => {
    // Getting initial context from options
    let context = options.context || {};
    // Checking if there are already running transitions on the given element.
    const running = runningTransitions.get(element);
    if (running) {
        switch (options.runningTransition) {
            // If there is one running and we want for it to 'continue' to run, we have to cancel the new one.
            // We're not emitting any values, but simply completing the observable (EMPTY).
            case 'continue':
                return EMPTY;
            // If there is one running and we want for it to 'stop', we have to complete the running one.
            // We're simply completing the running one and not emitting any values and merging newly provided context
            // with the one coming from currently running transition.
            case 'stop':
                zone.run(() => running.transition$.complete());
                context = Object.assign(running.context, context);
                runningTransitions.delete(element);
        }
    }
    // Running the start function
    const endFn = startFn(element, options.animation, context) || noopFn;
    // If 'prefer-reduced-motion' is enabled, the 'transition' will be set to 'none'.
    // If animations are disabled, we have to emit a value and complete the observable
    // In this case we have to call the end function, but can finish immediately by emitting a value,
    // completing the observable and executing end functions synchronously.
    if (!options.animation || window.getComputedStyle(element).transitionProperty === 'none') {
        zone.run(() => endFn());
        return of(undefined).pipe(runInZone(zone));
    }
    // Starting a new transition
    const transition$ = new Subject();
    const finishTransition$ = new Subject();
    const stop$ = transition$.pipe(endWith(true));
    runningTransitions.set(element, {
        transition$,
        complete: () => {
            finishTransition$.next();
            finishTransition$.complete();
        },
        context
    });
    const transitionDurationMs = getTransitionDurationMs(element);
    // 1. We have to both listen for the 'transitionend' event and have a 'just-in-case' timer,
    // because 'transitionend' event might not be fired in some browsers, if the transitioning
    // element becomes invisible (ex. when scrolling, making browser tab inactive, etc.). The timer
    // guarantees, that we'll release the DOM element and complete 'ngbRunTransition'.
    // 2. We need to filter transition end events, because they might bubble from shorter transitions
    // on inner DOM elements. We're only interested in the transition on the 'element' itself.
    zone.runOutsideAngular(() => {
        const transitionEnd$ = fromEvent(element, 'transitionend').pipe(takeUntil(stop$), filter(({ target }) => target === element));
        const timer$ = timer(transitionDurationMs + transitionTimerDelayMs).pipe(takeUntil(stop$));
        race(timer$, transitionEnd$, finishTransition$).pipe(takeUntil(stop$)).subscribe(() => {
            runningTransitions.delete(element);
            zone.run(() => {
                endFn();
                transition$.next();
                transition$.complete();
            });
        });
    });
    return transition$.asObservable();
};
export const ngbCompleteTransition = (element) => {
    var _a;
    (_a = runningTransitions.get(element)) === null || _a === void 0 ? void 0 : _a.complete();
};
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmdiVHJhbnNpdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLi9zcmMvIiwic291cmNlcyI6WyJ1dGlsL3RyYW5zaXRpb24vbmdiVHJhbnNpdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBYyxFQUFFLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDNUUsT0FBTyxFQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUQsT0FBTyxFQUFDLHVCQUF1QixFQUFDLE1BQU0sUUFBUSxDQUFDO0FBQy9DLE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUM5QyxPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBa0JsQyxNQUFNLE1BQU0sR0FBdUIsR0FBRyxFQUFFLEdBQUUsQ0FBQyxDQUFDOztBQUU1QyxNQUFNLEVBQUMsc0JBQXNCLEVBQUMsR0FBRyxXQUFXLENBQUM7QUFDN0MsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLEdBQUcsRUFBc0MsQ0FBQztBQUV6RSxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FDekIsQ0FBSSxJQUFZLEVBQUUsT0FBb0IsRUFBRSxPQUFnQyxFQUFFLE9BQWdDLEVBQ2hGLEVBQUU7SUFFdEIsdUNBQXVDO0lBQ3ZDLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLElBQU8sRUFBRSxDQUFDO0lBRXZDLDBFQUEwRTtJQUMxRSxNQUFNLE9BQU8sR0FBRyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDaEQsSUFBSSxPQUFPLEVBQUU7UUFDWCxRQUFRLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRTtZQUNqQyxrR0FBa0c7WUFDbEcsK0VBQStFO1lBQy9FLEtBQUssVUFBVTtnQkFDYixPQUFPLEtBQUssQ0FBQztZQUNmLDZG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Q0FBQztBQUVWLE1BQU0sQ0FBQyxNQUFNLHFCQUFxQixHQUFHLENBQUMsT0FBb0IsRUFBRSxFQUFFOztJQUM1RCxNQUFBLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsMENBQUcsUUFBUSxHQUFHO0FBQy9DLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Tmdab25lfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtFTVBUWSwgZnJvbUV2ZW50LCBPYnNlcnZhYmxlLCBvZiwgcmFjZSwgU3ViamVjdCwgdGltZXJ9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQge2VuZFdpdGgsIGZpbHRlciwgdGFrZVVudGlsfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7Z2V0VHJhbnNpdGlvbkR1cmF0aW9uTXN9IGZyb20gJy4vdXRpbCc7XHJcbmltcG9ydCB7ZW52aXJvbm1lbnR9IGZyb20gJy4uLy4uL2Vudmlyb25tZW50JztcclxuaW1wb3J0IHtydW5JblpvbmV9IGZyb20gJy4uL3V0aWwnO1xyXG5cclxuZXhwb3J0IHR5cGUgTmdiVHJhbnNpdGlvblN0YXJ0Rm48VCA9IGFueT4gPSAoZWxlbWVudDogSFRNTEVsZW1lbnQsIGFuaW1hdGlvbjogYm9vbGVhbiwgY29udGV4dDogVCkgPT5cclxuICAgIE5nYlRyYW5zaXRpb25FbmRGbiB8IHZvaWQ7XHJcbmV4cG9ydCB0eXBlIE5nYlRyYW5zaXRpb25FbmRGbiA9ICgpID0+IHZvaWQ7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE5nYlRyYW5zaXRpb25PcHRpb25zPFQ+IHtcclxuICBhbmltYXRpb246IGJvb2xlYW47XHJcbiAgcnVubmluZ1RyYW5zaXRpb246ICdjb250aW51ZScgfCAnc3RvcCc7XHJcbiAgY29udGV4dD86IFQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTmdiVHJhbnNpdGlvbkN0eDxUPiB7XHJcbiAgdHJhbnNpdGlvbiQ6IFN1YmplY3Q8YW55PjtcclxuICBjb21wbGV0ZTogKCkgPT4gdm9pZDtcclxuICBjb250ZXh0OiBUO1xyXG59XHJcblxyXG5jb25zdCBub29wRm46IE5nYlRyYW5zaXRpb25FbmRGbiA9ICgpID0+IHt9O1xyXG5cclxuY29uc3Qge3RyYW5zaXRpb25UaW1lckRlbGF5TXN9ID0gZW52aXJvbm1lbnQ7XHJcbmNvbnN0IHJ1bm5pbmdUcmFuc2l0aW9ucyA9IG5ldyBNYXA8SFRNTEVsZW1lbnQsIE5nYlRyYW5zaXRpb25DdHg8YW55Pj4oKTtcclxuXHJcbmV4cG9ydCBjb25zdCBuZ2JSdW5UcmFuc2l0aW9uID1cclxuICAgIDxUPih6b25lOiBOZ1pvbmUsIGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBzdGFydEZuOiBOZ2JUcmFuc2l0aW9uU3RhcnRGbjxUPiwgb3B0aW9uczogTmdiVHJhbnNpdGlvbk9wdGlvbnM8VD4pOlxyXG4gICAgICAgIE9ic2VydmFibGU8dW5kZWZpbmVkPiA9PiB7XHJcblxyXG4gICAgICAgICAgLy8gR2V0dGluZyBpbml0aWFsIGNvbnRleHQgZnJvbSBvcHRpb25zXHJcbiAgICAgICAgICBsZXQgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCB8fCA8VD57fTtcclxuXHJcbiAgICAgICAgICAvLyBDaGVja2luZyBpZiB0aGVyZSBhcmUgYWxyZWFkeSBydW5uaW5nIHRyYW5zaXRpb25zIG9uIHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gICAgICAgICAgY29uc3QgcnVubmluZyA9IHJ1bm5pbmdUcmFuc2l0aW9ucy5nZXQoZWxlbWVudCk7XHJcbiAgICAgICAgICBpZiAocnVubmluZykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wdGlvbnMucnVubmluZ1RyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBvbmUgcnVubmluZyBhbmQgd2Ugd2FudCBmb3IgaXQgdG8gJ2NvbnRpbnVlJyB0byBydW4sIHdlIGhhdmUgdG8gY2FuY2VsIHRoZSBuZXcgb25lLlxyXG4gICAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBlbWl0dGluZyBhbnkgdmFsdWVzLCBidXQgc2ltcGx5IGNvbXBsZXRpbmcgdGhlIG9ic2VydmFibGUgKEVNUFRZKS5cclxuICAgICAgICAgICAgICBjYXNlICdjb250aW51ZSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRU1QVFk7XHJcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgb25lIHJ1bm5pbmcgYW5kIHdlIHdhbnQgZm9yIGl0IHRvICdzdG9wJywgd2UgaGF2ZSB0byBjb21wbGV0ZSB0aGUgcnVubmluZyBvbmUuXHJcbiAgICAgICAgICAgICAgLy8gV2UncmUgc2ltcGx5IGNvbXBsZXRpbmcgdGhlIHJ1bm5pbmcgb25lIGFuZCBub3QgZW1pdHRpbmcgYW55IHZhbHVlcyBhbmQgbWVyZ2luZyBuZXdseSBwcm92aWRlZCBjb250ZXh0XHJcbiAgICAgICAgICAgICAgLy8gd2l0aCB0aGUgb25lIGNvbWluZyBmcm9tIGN1cnJlbnRseSBydW5uaW5nIHRyYW5zaXRpb24uXHJcbiAgICAgICAgICAgICAgY2FzZSAnc3RvcCc6XHJcbiAgICAgICAgICAgICAgICB6b25lLnJ1bigoKSA9PiBydW5uaW5nLnRyYW5zaXRpb24kLmNvbXBsZXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IE9iamVjdC5hc3NpZ24ocnVubmluZy5jb250ZXh0LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIHJ1bm5pbmdUcmFuc2l0aW9ucy5kZWxldGUoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSdW5uaW5nIHRoZSBzdGFydCBmdW5jdGlvblxyXG4gICAgICAgICAgY29uc3QgZW5kRm4gPSBzdGFydEZuKGVsZW1lbnQsIG9wdGlvbnMuYW5pbWF0aW9uLCBjb250ZXh0KSB8fCBub29wRm47XHJcblxyXG4gICAgICAgICAgLy8gSWYgJ3ByZWZlci1yZWR1Y2VkLW1vdGlvbicgaXMgZW5hYmxlZCwgdGhlICd0cmFuc2l0aW9uJyB3aWxsIGJlIHNldCB0byAnbm9uZScuXHJcbiAgICAgICAgICAvLyBJZiBhbmltYXRpb25zIGFyZSBkaXNhYmxlZCwgd2UgaGF2ZSB0byBlbWl0IGEgdmFsdWUgYW5kIGNvbXBsZXRlIHRoZSBvYnNlcnZhYmxlXHJcbiAgICAgICAgICAvLyBJbiB0aGlzIGNhc2Ugd2UgaGF2ZSB0byBjYWxsIHRoZSBlbmQgZnVuY3Rpb24sIGJ1dCBjYW4gZmluaXNoIGltbWVkaWF0ZWx5IGJ5IGVtaXR0aW5nIGEgdmFsdWUsXHJcbiAgICAgICAgICAvLyBjb21wbGV0aW5nIHRoZSBvYnNlcnZhYmxlIGFuZCBleGVjdXRpbmcgZW5kIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5LlxyXG4gICAgICAgICAgaWYgKCFvcHRpb25zLmFuaW1hdGlvbiB8fCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS50cmFuc2l0aW9uUHJvcGVydHkgPT09ICdub25lJykge1xyXG4gICAgICAgICAgICB6b25lLnJ1bigoKSA9PiBlbmRGbigpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG9mKHVuZGVmaW5lZCkucGlwZShydW5JblpvbmUoem9uZSkpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFN0YXJ0aW5nIGEgbmV3IHRyYW5zaXRpb25cclxuICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb24kID0gbmV3IFN1YmplY3Q8YW55PigpO1xyXG4gICAgICAgICAgY29uc3QgZmluaXNoVHJhbnNpdGlvbiQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XHJcbiAgICAgICAgICBjb25zdCBzdG9wJCA9IHRyYW5zaXRpb24kLnBpcGUoZW5kV2l0aCh0cnVlKSk7XHJcbiAgICAgICAgICBydW5uaW5nVHJhbnNpdGlvbnMuc2V0KGVsZW1lbnQsIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbiQsXHJcbiAgICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgZmluaXNoVHJhbnNpdGlvbiQubmV4dCgpO1xyXG4gICAgICAgICAgICAgIGZpbmlzaFRyYW5zaXRpb24kLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbnRleHRcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbk1zID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uTXMoZWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgLy8gMS4gV2UgaGF2ZSB0byBib3RoIGxpc3RlbiBmb3IgdGhlICd0cmFuc2l0aW9uZW5kJyBldmVudCBhbmQgaGF2ZSBhICdqdXN0LWluLWNhc2UnIHRpbWVyLFxyXG4gICAgICAgICAgLy8gYmVjYXVzZSAndHJhbnNpdGlvbmVuZCcgZXZlbnQgbWlnaHQgbm90IGJlIGZpcmVkIGluIHNvbWUgYnJvd3NlcnMsIGlmIHRoZSB0cmFuc2l0aW9uaW5nXHJcbiAgICAgICAgICAvLyBlbGVtZW50IGJlY29tZXMgaW52aXNpYmxlIChleC4gd2hlbiBzY3JvbGxpbmcsIG1ha2luZyBicm93c2VyIHRhYiBpbmFjdGl2ZSwgZXRjLikuIFRoZSB0aW1lclxyXG4gICAgICAgICAgLy8gZ3VhcmFudGVlcywgdGhhdCB3ZSdsbCByZWxlYXNlIHRoZSBET00gZWxlbWVudCBhbmQgY29tcGxldGUgJ25nYlJ1blRyYW5zaXRpb24nLlxyXG4gICAgICAgICAgLy8gMi4gV2UgbmVlZCB0byBmaWx0ZXIgdHJhbnNpdGlvbiBlbmQgZXZlbnRzLCBiZWNhdXNlIHRoZXkgbWlnaHQgYnViYmxlIGZyb20gc2hvcnRlciB0cmFuc2l0aW9uc1xyXG4gICAgICAgICAgLy8gb24gaW5uZXIgRE9NIGVsZW1lbnRzLiBXZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gdGhlIHRyYW5zaXRpb24gb24gdGhlICdlbGVtZW50JyBpdHNlbGYuXHJcbiAgICAgICAgICB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNpdGlvbkVuZCQgPVxyXG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KGVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJykucGlwZSh0YWtlVW50aWwoc3RvcCQpLCBmaWx0ZXIoKHt0YXJnZXR9KSA9PiB0YXJnZXQgPT09IGVsZW1lbnQpKTtcclxuICAgICAgICAgICAgY29uc3QgdGltZXIkID0gdGltZXIodHJhbnNpdGlvbkR1cmF0aW9uTXMgKyB0cmFuc2l0aW9uVGltZXJEZWxheU1zKS5waXBlKHRha2VVbnRpbChzdG9wJCkpO1xyXG5cclxuICAgICAgICAgICAgcmFjZSh0aW1lciQsIHRyYW5zaXRpb25FbmQkLCBmaW5pc2hUcmFuc2l0aW9uJCkucGlwZSh0YWtlVW50aWwoc3RvcCQpKS5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgIHJ1bm5pbmdUcmFuc2l0aW9ucy5kZWxldGUoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZW5kRm4oKTtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24kLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24kLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHRyYW5zaXRpb24kLmFzT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgIH07XHJcblxyXG5leHBvcnQgY29uc3QgbmdiQ29tcGxldGVUcmFuc2l0aW9uID0gKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSA9PiB7XHJcbiAgcnVubmluZ1RyYW5zaXRpb25zLmdldChlbGVtZW50KSA/LmNvbXBsZXRlKCk7XHJcbn07XHJcbiJdfQ==