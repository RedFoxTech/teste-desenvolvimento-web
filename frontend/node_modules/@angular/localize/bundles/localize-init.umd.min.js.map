{"version":3,"sources":["packages/localize/localize-init.umd.js"],"names":["global","factory","exports","module","define","amd","self","ng","localize","init","this","__globalThis","globalThis","__window","window","__self","WorkerGlobalScope","__global","$localize","messageParts","expressions","_i","arguments","length","translate","translation","message","stripBlock","raw","i","messagePart","rawMessagePart","charAt","substring","findEndOfBlock","cooked","cookedIndex","rawIndex","Error","Object","defineProperty","value"],"mappings":";;;;;CAMC,SAAUA,EAAQC,GACI,iBAAZC,SAA0C,oBAAXC,OAAyBF,EAAQC,SACrD,mBAAXE,QAAyBA,OAAOC,IAAMD,OAAO,yBAA0B,CAAC,WAAYH,GACjEA,IAAzBD,EAASA,GAAUM,MAAsBC,GAAKP,EAAOO,IAAM,GAAIP,EAAOO,GAAGC,SAAWR,EAAOO,GAAGC,UAAY,GAAIR,EAAOO,GAAGC,SAASC,KAAO,KAH7I,CAIEC,MAAM,SAAWR,GAAW;;;;;;;OAS1B,IAAIS,EAAqC,oBAAfC,YAA8BA,WACpDC,EAA6B,oBAAXC,QAA0BA,OAC5CC,EAAyB,oBAATT,MAAqD,oBAAtBU,mBAC/CV,gBAAgBU,mBAAqBV,KACrCW,EAA6B,oBAAXjB,QAA0BA,OA4G5CkB,EAAY,SAAUC,GAEtB,IADA,IAAIC,EAAc,GACTC,EAAK,EAAGA,EAAKC,UAAUC,OAAQF,IACpCD,EAAYC,EAAK,GAAKC,UAAUD,GAEpC,GAAIH,EAAUM,UAAW,CAErB,IAAIC,EAAcP,EAAUM,UAAUL,EAAcC,GACpDD,EAAeM,EAAY,GAC3BL,EAAcK,EAAY,GAG9B,IADA,IAAIC,EAAUC,EAAWR,EAAa,GAAIA,EAAaS,IAAI,IAClDC,EAAI,EAAGA,EAAIV,EAAaI,OAAQM,IACrCH,GAAWN,EAAYS,EAAI,GAAKF,EAAWR,EAAaU,GAAIV,EAAaS,IAAIC,IAEjF,OAAOH,GAgBX,SAASC,EAAWG,EAAaC,GAC7B,MAfe,MAeRA,EAAeC,OAAO,GACzBF,EAAYG,UAYpB,SAASC,EAAeC,EAAQP,GAO5B,IAAK,IAAIQ,EAAc,EAAGC,EAAW,EAAGD,EAAcD,EAAOZ,OAAQa,IAAeC,IAChF,GAAsB,OAAlBT,EAAIS,GACJA,SAEC,GAvCM,MAuCFF,EAAOC,GACZ,OAAOA,EAGf,MAAM,IAAIE,MAAM,6CAAgDV,EAAM;;;;;;;;;;;;;;OA3B5CM,CAAeJ,EAAaC,GAAkB,GACpED,GA1IMnB,GAAgBM,GAAYJ,GAAYE,GAuL9CG,UAAYA,EAEpBhB,EAAQgB,UAAYA,EAEpBqB,OAAOC,eAAetC,EAAS,aAAc,CAAEuC,OAAO","sourcesContent":["/**\n * @license Angular v11.2.14\n * (c) 2010-2021 Google LLC. https://angular.io/\n * License: MIT\n */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define('@angular/localize/init', ['exports'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.localize = global.ng.localize || {}, global.ng.localize.init = {})));\n}(this, (function (exports) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __globalThis = typeof globalThis !== 'undefined' && globalThis;\n    var __window = typeof window !== 'undefined' && window;\n    var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n        self instanceof WorkerGlobalScope && self;\n    var __global = typeof global !== 'undefined' && global;\n    // Always use __globalThis if available; this is the spec-defined global variable across all\n    // environments.\n    // Then fallback to __global first; in Node tests both __global and __window may be defined.\n    var _global = __globalThis || __global || __window || __self;\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Tag a template literal string for localization.\n     *\n     * For example:\n     *\n     * ```ts\n     * $localize `some string to localize`\n     * ```\n     *\n     * **Providing meaning, description and id**\n     *\n     * You can optionally specify one or more of `meaning`, `description` and `id` for a localized\n     * string by pre-pending it with a colon delimited block of the form:\n     *\n     * ```ts\n     * $localize`:meaning|description@@id:source message text`;\n     *\n     * $localize`:meaning|:source message text`;\n     * $localize`:description:source message text`;\n     * $localize`:@@id:source message text`;\n     * ```\n     *\n     * This format is the same as that used for `i18n` markers in Angular templates. See the\n     * [Angular 18n guide](guide/i18n#mark-text-for-translations).\n     *\n     * **Naming placeholders**\n     *\n     * If the template literal string contains expressions, then the expressions will be automatically\n     * associated with placeholder names for you.\n     *\n     * For example:\n     *\n     * ```ts\n     * $localize `Hi ${name}! There are ${items.length} items.`;\n     * ```\n     *\n     * will generate a message-source of `Hi {$PH}! There are {$PH_1} items`.\n     *\n     * The recommended practice is to name the placeholder associated with each expression though.\n     *\n     * Do this by providing the placeholder name wrapped in `:` characters directly after the\n     * expression. These placeholder names are stripped out of the rendered localized string.\n     *\n     * For example, to name the `items.length` expression placeholder `itemCount` you write:\n     *\n     * ```ts\n     * $localize `There are ${items.length}:itemCount: items`;\n     * ```\n     *\n     * **Escaping colon markers**\n     *\n     * If you need to use a `:` character directly at the start of a tagged string that has no\n     * metadata block, or directly after a substitution expression that has no name you must escape\n     * the `:` by preceding it with a backslash:\n     *\n     * For example:\n     *\n     * ```ts\n     * // message has a metadata block so no need to escape colon\n     * $localize `:some description::this message starts with a colon (:)`;\n     * // no metadata block so the colon must be escaped\n     * $localize `\\:this message starts with a colon (:)`;\n     * ```\n     *\n     * ```ts\n     * // named substitution so no need to escape colon\n     * $localize `${label}:label:: ${}`\n     * // anonymous substitution so colon must be escaped\n     * $localize `${label}\\: ${}`\n     * ```\n     *\n     * **Processing localized strings:**\n     *\n     * There are three scenarios:\n     *\n     * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a\n     * transpiler, removing the tag and replacing the template literal string with a translated\n     * literal string from a collection of translations provided to the transpilation tool.\n     *\n     * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and\n     * reorders the parts (static strings and expressions) of the template literal string with strings\n     * from a collection of translations loaded at run-time.\n     *\n     * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates\n     * the original template literal string without applying any translations to the parts. This\n     * version is used during development or where there is no need to translate the localized\n     * template literals.\n     *\n     * @param messageParts a collection of the static parts of the template string.\n     * @param expressions a collection of the values of each placeholder in the template string.\n     * @returns the translated string, with the `messageParts` and `expressions` interleaved together.\n     *\n     * @globalApi\n     * @publicApi\n     */\n    var $localize = function (messageParts) {\n        var expressions = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            expressions[_i - 1] = arguments[_i];\n        }\n        if ($localize.translate) {\n            // Don't use array expansion here to avoid the compiler adding `__read()` helper unnecessarily.\n            var translation = $localize.translate(messageParts, expressions);\n            messageParts = translation[0];\n            expressions = translation[1];\n        }\n        var message = stripBlock(messageParts[0], messageParts.raw[0]);\n        for (var i = 1; i < messageParts.length; i++) {\n            message += expressions[i - 1] + stripBlock(messageParts[i], messageParts.raw[i]);\n        }\n        return message;\n    };\n    var BLOCK_MARKER = ':';\n    /**\n     * Strip a delimited \"block\" from the start of the `messagePart`, if it is found.\n     *\n     * If a marker character (:) actually appears in the content at the start of a tagged string or\n     * after a substitution expression, where a block has not been provided the character must be\n     * escaped with a backslash, `\\:`. This function checks for this by looking at the `raw`\n     * messagePart, which should still contain the backslash.\n     *\n     * @param messagePart The cooked message part to process.\n     * @param rawMessagePart The raw message part to check.\n     * @returns the message part with the placeholder name stripped, if found.\n     * @throws an error if the block is unterminated\n     */\n    function stripBlock(messagePart, rawMessagePart) {\n        return rawMessagePart.charAt(0) === BLOCK_MARKER ?\n            messagePart.substring(findEndOfBlock(messagePart, rawMessagePart) + 1) :\n            messagePart;\n    }\n    /**\n     * Find the end of a \"marked block\" indicated by the first non-escaped colon.\n     *\n     * @param cooked The cooked string (where escaped chars have been processed)\n     * @param raw The raw string (where escape sequences are still in place)\n     *\n     * @returns the index of the end of block marker\n     * @throws an error if the block is unterminated\n     */\n    function findEndOfBlock(cooked, raw) {\n        /***********************************************************************************************\n         * This function is repeated in `src/utils/messages.ts` and the two should be kept in sync.\n         * The reason is that this file is marked as having side-effects, and if we import `messages.ts`\n         * into it, the whole of `src/utils` will be included in this bundle and none of the functions\n         * will be tree shaken.\n         ***********************************************************************************************/\n        for (var cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {\n            if (raw[rawIndex] === '\\\\') {\n                rawIndex++;\n            }\n            else if (cooked[cookedIndex] === BLOCK_MARKER) {\n                return cookedIndex;\n            }\n        }\n        throw new Error(\"Unterminated $localize metadata block in \\\"\" + raw + \"\\\".\");\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Attach $localize to the global context, as a side-effect of this module.\n    _global.$localize = $localize;\n\n    exports.$localize = $localize;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=localize-init.umd.js.map\n"]}