{"version":3,"file":"localize.js","sources":["../../../../../../packages/localize/src/utils/src/constants.ts","../../../../../../packages/localize/src/utils/src/messages.ts","../../../../../../packages/localize/src/utils/src/translations.ts","../../../../../../packages/localize/src/utils/index.ts","../../../../../../packages/localize/src/translate.ts","../../../../../../packages/localize/private.ts","../../../../../../packages/localize/localize.ts","../../../../../../packages/localize/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The character used to mark the start and end of a \"block\" in a `$localize` tagged string.\n * A block can indicate metadata about the message or specify a name of a placeholder for a\n * substitution expressions.\n *\n * For example:\n *\n * ```ts\n * $localize`Hello, ${title}:title:!`;\n * $localize`:meaning|description@@id:source message text`;\n * ```\n */\nexport const BLOCK_MARKER = ':';\n\n/**\n * The marker used to separate a message's \"meaning\" from its \"description\" in a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:correct|Indicates that the user got the answer correct: Right!`;\n * $localize `:movement|Button label for moving to the right: Right!`;\n * ```\n */\nexport const MEANING_SEPARATOR = '|';\n\n/**\n * The marker used to separate a message's custom \"id\" from its \"description\" in a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:A welcome message on the home page@@myApp-homepage-welcome: Welcome!`;\n * ```\n */\nexport const ID_SEPARATOR = '@@';\n\n/**\n * The marker used to separate legacy message ids from the rest of a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:@@custom-id␟2df64767cd895a8fabe3e18b94b5b6b6f9e2e3f0: Welcome!`;\n * ```\n *\n * Note that this character is the \"symbol for the unit separator\" (␟) not the \"unit separator\n * character\" itself, since that has no visual representation. See https://graphemica.com/%E2%90%9F.\n *\n * Here is some background for the original \"unit separator character\":\n * https://stackoverflow.com/questions/8695118/whats-the-file-group-record-unit-separator-control-characters-and-its-usage\n */\nexport const LEGACY_ID_INDICATOR = '\\u241F';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {computeMsgId} from '@angular/compiler';\nimport {AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file_system';\n\nimport {BLOCK_MARKER, ID_SEPARATOR, LEGACY_ID_INDICATOR, MEANING_SEPARATOR} from './constants';\n\n/**\n * Re-export this helper function so that users of `@angular/localize` don't need to actively import\n * from `@angular/compiler`.\n */\nexport {computeMsgId} from '@angular/compiler';\n\n/**\n * A string containing a translation source message.\n *\n * I.E. the message that indicates what will be translated from.\n *\n * Uses `{$placeholder-name}` to indicate a placeholder.\n */\nexport type SourceMessage = string;\n\n/**\n * A string containing a translation target message.\n *\n * I.E. the message that indicates what will be translated to.\n *\n * Uses `{$placeholder-name}` to indicate a placeholder.\n */\nexport type TargetMessage = string;\n\n/**\n * A string that uniquely identifies a message, to be used for matching translations.\n */\nexport type MessageId = string;\n\n/**\n * The location of the message in the source file.\n *\n * The `line` and `column` values for the `start` and `end` properties are zero-based.\n */\nexport interface SourceLocation {\n  start: {line: number, column: number};\n  end: {line: number, column: number};\n  file: AbsoluteFsPath;\n  text?: string;\n}\n\n/**\n * Additional information that can be associated with a message.\n */\nexport interface MessageMetadata {\n  /**\n   * A human readable rendering of the message\n   */\n  text: string;\n  /**\n   * Legacy message ids, if provided.\n   *\n   * In legacy message formats the message id can only be computed directly from the original\n   * template source.\n   *\n   * Since this information is not available in `$localize` calls, the legacy message ids may be\n   * attached by the compiler to the `$localize` metablock so it can be used if needed at the point\n   * of translation if the translations are encoded using the legacy message id.\n   */\n  legacyIds?: string[];\n  /**\n   * The id of the `message` if a custom one was specified explicitly.\n   *\n   * This id overrides any computed or legacy ids.\n   */\n  customId?: string;\n  /**\n   * The meaning of the `message`, used to distinguish identical `messageString`s.\n   */\n  meaning?: string;\n  /**\n   * The description of the `message`, used to aid translation.\n   */\n  description?: string;\n  /**\n   * The location of the message in the source.\n   */\n  location?: SourceLocation;\n}\n\n/**\n * Information parsed from a `$localize` tagged string that is used to translate it.\n *\n * For example:\n *\n * ```\n * const name = 'Jo Bloggs';\n * $localize`Hello ${name}:title!`;\n * ```\n *\n * May be parsed into:\n *\n * ```\n * {\n *   id: '6998194507597730591',\n *   substitutions: { title: 'Jo Bloggs' },\n *   messageString: 'Hello {$title}!',\n * }\n * ```\n */\nexport interface ParsedMessage extends MessageMetadata {\n  /**\n   * The key used to look up the appropriate translation target.\n   */\n  id: MessageId;\n  /**\n   * A mapping of placeholder names to substitution values.\n   */\n  substitutions: Record<string, any>;\n  /**\n   * An optional mapping of placeholder names to source locations\n   */\n  substitutionLocations?: Record<string, SourceLocation|undefined>;\n  /**\n   * The static parts of the message.\n   */\n  messageParts: string[];\n  /**\n   * An optional mapping of message parts to source locations\n   */\n  messagePartLocations?: (SourceLocation|undefined)[];\n  /**\n   * The names of the placeholders that will be replaced with substitutions.\n   */\n  placeholderNames: string[];\n}\n\n/**\n * Parse a `$localize` tagged string into a structure that can be used for translation or\n * extraction.\n *\n * See `ParsedMessage` for an example.\n */\nexport function parseMessage(\n    messageParts: TemplateStringsArray, expressions?: readonly any[], location?: SourceLocation,\n    messagePartLocations?: (SourceLocation|undefined)[],\n    expressionLocations: (SourceLocation|undefined)[] = []): ParsedMessage {\n  const substitutions: {[placeholderName: string]: any} = {};\n  const substitutionLocations: {[placeholderName: string]: SourceLocation|undefined} = {};\n  const metadata = parseMetadata(messageParts[0], messageParts.raw[0]);\n  const cleanedMessageParts: string[] = [metadata.text];\n  const placeholderNames: string[] = [];\n  let messageString = metadata.text;\n  for (let i = 1; i < messageParts.length; i++) {\n    const {text: messagePart, block: placeholderName = computePlaceholderName(i)} =\n        splitBlock(messageParts[i], messageParts.raw[i]);\n    messageString += `{$${placeholderName}}${messagePart}`;\n    if (expressions !== undefined) {\n      substitutions[placeholderName] = expressions[i - 1];\n      substitutionLocations[placeholderName] = expressionLocations[i - 1];\n    }\n    placeholderNames.push(placeholderName);\n    cleanedMessageParts.push(messagePart);\n  }\n  const messageId = metadata.customId || computeMsgId(messageString, metadata.meaning || '');\n  const legacyIds = metadata.legacyIds ? metadata.legacyIds.filter(id => id !== messageId) : [];\n  return {\n    id: messageId,\n    legacyIds,\n    substitutions,\n    substitutionLocations,\n    text: messageString,\n    customId: metadata.customId,\n    meaning: metadata.meaning || '',\n    description: metadata.description || '',\n    messageParts: cleanedMessageParts,\n    messagePartLocations,\n    placeholderNames,\n    location,\n  };\n}\n\n/**\n * Parse the given message part (`cooked` + `raw`) to extract the message metadata from the text.\n *\n * If the message part has a metadata block this function will extract the `meaning`,\n * `description`, `customId` and `legacyId` (if provided) from the block. These metadata properties\n * are serialized in the string delimited by `|`, `@@` and `␟` respectively.\n *\n * (Note that `␟` is the `LEGACY_ID_INDICATOR` - see `constants.ts`.)\n *\n * For example:\n *\n * ```ts\n * `:meaning|description@@custom-id`\n * `:meaning|@@custom-id`\n * `:meaning|description`\n * `description@@custom-id`\n * `meaning|`\n * `description`\n * `@@custom-id`\n * `:meaning|description@@custom-id␟legacy-id-1␟legacy-id-2`\n * ```\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns A object containing any metadata that was parsed from the message part.\n */\nexport function parseMetadata(cooked: string, raw: string): MessageMetadata {\n  const {text: messageString, block} = splitBlock(cooked, raw);\n  if (block === undefined) {\n    return {text: messageString};\n  } else {\n    const [meaningDescAndId, ...legacyIds] = block.split(LEGACY_ID_INDICATOR);\n    const [meaningAndDesc, customId] = meaningDescAndId.split(ID_SEPARATOR, 2);\n    let [meaning, description]: (string|undefined)[] = meaningAndDesc.split(MEANING_SEPARATOR, 2);\n    if (description === undefined) {\n      description = meaning;\n      meaning = undefined;\n    }\n    if (description === '') {\n      description = undefined;\n    }\n    return {text: messageString, meaning, description, customId, legacyIds};\n  }\n}\n\n/**\n * Split a message part (`cooked` + `raw`) into an optional delimited \"block\" off the front and the\n * rest of the text of the message part.\n *\n * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the\n * start and end of the block.\n *\n * If the block is in the first message part then it will be metadata about the whole message:\n * meaning, description, id.  Otherwise it will be metadata about the immediately preceding\n * substitution: placeholder name.\n *\n * Since blocks are optional, it is possible that the content of a message block actually starts\n * with a block marker. In this case the marker must be escaped `\\:`.\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns An object containing the `text` of the message part and the text of the `block`, if it\n * exists.\n * @throws an error if the `block` is unterminated\n */\nexport function splitBlock(cooked: string, raw: string): {text: string, block?: string} {\n  if (raw.charAt(0) !== BLOCK_MARKER) {\n    return {text: cooked};\n  } else {\n    const endOfBlock = findEndOfBlock(cooked, raw);\n    return {\n      block: cooked.substring(1, endOfBlock),\n      text: cooked.substring(endOfBlock + 1),\n    };\n  }\n}\n\n\nfunction computePlaceholderName(index: number) {\n  return index === 1 ? 'PH' : `PH_${index - 1}`;\n}\n\n/**\n * Find the end of a \"marked block\" indicated by the first non-escaped colon.\n *\n * @param cooked The cooked string (where escaped chars have been processed)\n * @param raw The raw string (where escape sequences are still in place)\n *\n * @returns the index of the end of block marker\n * @throws an error if the block is unterminated\n */\nexport function findEndOfBlock(cooked: string, raw: string): number {\n  /************************************************************************************************\n   * This function is repeated in `src/localize/src/localize.ts` and the two should be kept in sync.\n   * (See that file for more explanation of why.)\n   ************************************************************************************************/\n  for (let cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {\n    if (raw[rawIndex] === '\\\\') {\n      rawIndex++;\n    } else if (cooked[cookedIndex] === BLOCK_MARKER) {\n      return cookedIndex;\n    }\n  }\n  throw new Error(`Unterminated $localize metadata block in \"${raw}\".`);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {BLOCK_MARKER} from './constants';\nimport {MessageId, MessageMetadata, ParsedMessage, parseMessage, TargetMessage} from './messages';\n\n\n/**\n * A translation message that has been processed to extract the message parts and placeholders.\n */\nexport interface ParsedTranslation extends MessageMetadata {\n  messageParts: TemplateStringsArray;\n  placeholderNames: string[];\n}\n\n/**\n * The internal structure used by the runtime localization to translate messages.\n */\nexport type ParsedTranslations = Record<MessageId, ParsedTranslation>;\n\nexport class MissingTranslationError extends Error {\n  private readonly type = 'MissingTranslationError';\n  constructor(readonly parsedMessage: ParsedMessage) {\n    super(`No translation found for ${describeMessage(parsedMessage)}.`);\n  }\n}\n\nexport function isMissingTranslationError(e: any): e is MissingTranslationError {\n  return e.type === 'MissingTranslationError';\n}\n\n/**\n * Translate the text of the `$localize` tagged-string (i.e. `messageParts` and\n * `substitutions`) using the given `translations`.\n *\n * The tagged-string is parsed to extract its `messageId` which is used to find an appropriate\n * `ParsedTranslation`. If this doesn't match and there are legacy ids then try matching a\n * translation using those.\n *\n * If one is found then it is used to translate the message into a new set of `messageParts` and\n * `substitutions`.\n * The translation may reorder (or remove) substitutions as appropriate.\n *\n * If there is no translation with a matching message id then an error is thrown.\n * If a translation contains a placeholder that is not found in the message being translated then an\n * error is thrown.\n */\nexport function translate(\n    translations: Record<string, ParsedTranslation>, messageParts: TemplateStringsArray,\n    substitutions: readonly any[]): [TemplateStringsArray, readonly any[]] {\n  const message = parseMessage(messageParts, substitutions);\n  // Look up the translation using the messageId, and then the legacyId if available.\n  let translation = translations[message.id];\n  // If the messageId did not match a translation, try matching the legacy ids instead\n  if (message.legacyIds !== undefined) {\n    for (let i = 0; i < message.legacyIds.length && translation === undefined; i++) {\n      translation = translations[message.legacyIds[i]];\n    }\n  }\n  if (translation === undefined) {\n    throw new MissingTranslationError(message);\n  }\n  return [\n    translation.messageParts, translation.placeholderNames.map(placeholder => {\n      if (message.substitutions.hasOwnProperty(placeholder)) {\n        return message.substitutions[placeholder];\n      } else {\n        throw new Error(\n            `There is a placeholder name mismatch with the translation provided for the message ${\n                describeMessage(message)}.\\n` +\n            `The translation contains a placeholder with name ${\n                placeholder}, which does not exist in the message.`);\n      }\n    })\n  ];\n}\n\n/**\n * Parse the `messageParts` and `placeholderNames` out of a target `message`.\n *\n * Used by `loadTranslations()` to convert target message strings into a structure that is more\n * appropriate for doing translation.\n *\n * @param message the message to be parsed.\n */\nexport function parseTranslation(messageString: TargetMessage): ParsedTranslation {\n  const parts = messageString.split(/{\\$([^}]*)}/);\n  const messageParts = [parts[0]];\n  const placeholderNames: string[] = [];\n  for (let i = 1; i < parts.length - 1; i += 2) {\n    placeholderNames.push(parts[i]);\n    messageParts.push(`${parts[i + 1]}`);\n  }\n  const rawMessageParts =\n      messageParts.map(part => part.charAt(0) === BLOCK_MARKER ? '\\\\' + part : part);\n  return {\n    text: messageString,\n    messageParts: makeTemplateObject(messageParts, rawMessageParts),\n    placeholderNames,\n  };\n}\n\n/**\n * Create a `ParsedTranslation` from a set of `messageParts` and `placeholderNames`.\n *\n * @param messageParts The message parts to appear in the ParsedTranslation.\n * @param placeholderNames The names of the placeholders to intersperse between the `messageParts`.\n */\nexport function makeParsedTranslation(\n    messageParts: string[], placeholderNames: string[] = []): ParsedTranslation {\n  let messageString = messageParts[0];\n  for (let i = 0; i < placeholderNames.length; i++) {\n    messageString += `{$${placeholderNames[i]}}${messageParts[i + 1]}`;\n  }\n  return {\n    text: messageString,\n    messageParts: makeTemplateObject(messageParts, messageParts),\n    placeholderNames\n  };\n}\n\n/**\n * Create the specialized array that is passed to tagged-string tag functions.\n *\n * @param cooked The message parts with their escape codes processed.\n * @param raw The message parts with their escaped codes as-is.\n */\nexport function makeTemplateObject(cooked: string[], raw: string[]): TemplateStringsArray {\n  Object.defineProperty(cooked, 'raw', {value: raw});\n  return cooked as any;\n}\n\n\nfunction describeMessage(message: ParsedMessage): string {\n  const meaningString = message.meaning && ` - \"${message.meaning}\"`;\n  const legacy = message.legacyIds && message.legacyIds.length > 0 ?\n      ` [${message.legacyIds.map(l => `\"${l}\"`).join(', ')}]` :\n      '';\n  return `\"${message.id}\"${legacy} (\"${message.text}\"${meaningString})`;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport * from './src/constants';\nexport * from './src/messages';\nexport * from './src/translations';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {LocalizeFn} from './localize';\nimport {MessageId, ParsedTranslation, parseTranslation, TargetMessage, translate as _translate} from './utils';\n\n/**\n * We augment the `$localize` object to also store the translations.\n *\n * Note that because the TRANSLATIONS are attached to a global object, they will be shared between\n * all applications that are running in a single page of the browser.\n */\ndeclare const $localize: LocalizeFn&{TRANSLATIONS: Record<MessageId, ParsedTranslation>};\n\n/**\n * Load translations for use by `$localize`, if doing runtime translation.\n *\n * If the `$localize` tagged strings are not going to be replaced at compiled time, it is possible\n * to load a set of translations that will be applied to the `$localize` tagged strings at runtime,\n * in the browser.\n *\n * Loading a new translation will overwrite a previous translation if it has the same `MessageId`.\n *\n * Note that `$localize` messages are only processed once, when the tagged string is first\n * encountered, and does not provide dynamic language changing without refreshing the browser.\n * Loading new translations later in the application life-cycle will not change the translated text\n * of messages that have already been translated.\n *\n * The message IDs and translations are in the same format as that rendered to \"simple JSON\"\n * translation files when extracting messages. In particular, placeholders in messages are rendered\n * using the `{$PLACEHOLDER_NAME}` syntax. For example the message from the following template:\n *\n * ```html\n * <div i18n>pre<span>inner-pre<b>bold</b>inner-post</span>post</div>\n * ```\n *\n * would have the following form in the `translations` map:\n *\n * ```ts\n * {\n *   \"2932901491976224757\":\n *      \"pre{$START_TAG_SPAN}inner-pre{$START_BOLD_TEXT}bold{$CLOSE_BOLD_TEXT}inner-post{$CLOSE_TAG_SPAN}post\"\n * }\n * ```\n *\n * @param translations A map from message ID to translated message.\n *\n * These messages are processed and added to a lookup based on their `MessageId`.\n *\n * @see `clearTranslations()` for removing translations loaded using this function.\n * @see `$localize` for tagging messages as needing to be translated.\n * @publicApi\n */\nexport function loadTranslations(translations: Record<MessageId, TargetMessage>) {\n  // Ensure the translate function exists\n  if (!$localize.translate) {\n    $localize.translate = translate;\n  }\n  if (!$localize.TRANSLATIONS) {\n    $localize.TRANSLATIONS = {};\n  }\n  Object.keys(translations).forEach(key => {\n    $localize.TRANSLATIONS[key] = parseTranslation(translations[key]);\n  });\n}\n\n/**\n * Remove all translations for `$localize`, if doing runtime translation.\n *\n * All translations that had been loading into memory using `loadTranslations()` will be removed.\n *\n * @see `loadTranslations()` for loading translations at runtime.\n * @see `$localize` for tagging messages as needing to be translated.\n *\n * @publicApi\n */\nexport function clearTranslations() {\n  $localize.translate = undefined;\n  $localize.TRANSLATIONS = {};\n}\n\n/**\n * Translate the text of the given message, using the loaded translations.\n *\n * This function may reorder (or remove) substitutions as indicated in the matching translation.\n */\nexport function translate(messageParts: TemplateStringsArray, substitutions: readonly any[]):\n    [TemplateStringsArray, readonly any[]] {\n  try {\n    return _translate($localize.TRANSLATIONS, messageParts, substitutions);\n  } catch (e) {\n    console.warn(e.message);\n    return [messageParts, substitutions];\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// This file exports all the `utils` as private exports so that other parts of `@angular/localize`\n// can make use of them.\nexport {computeMsgId as ɵcomputeMsgId, findEndOfBlock as ɵfindEndOfBlock, isMissingTranslationError as ɵisMissingTranslationError, makeParsedTranslation as ɵmakeParsedTranslation, makeTemplateObject as ɵmakeTemplateObject, MessageId as ɵMessageId, MissingTranslationError as ɵMissingTranslationError, ParsedMessage as ɵParsedMessage, ParsedTranslation as ɵParsedTranslation, ParsedTranslations as ɵParsedTranslations, parseMessage as ɵparseMessage, parseMetadata as ɵparseMetadata, parseTranslation as ɵparseTranslation, SourceLocation as ɵSourceLocation, SourceMessage as ɵSourceMessage, splitBlock as ɵsplitBlock, TargetMessage as ɵTargetMessage, translate as ɵtranslate} from './src/utils';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// This file contains the public API of the `@angular/localize` entry-point\n\nexport {clearTranslations, loadTranslations} from './src/translate';\n\n// Exports that are not part of the public API\nexport * from './private';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// DO NOT ADD public exports to this file.\n// The public API exports are specified in the `./localize` module, which is checked by the\n// public_api_guard rules\n\nexport * from './localize';\n"],"names":["translate","_translate"],"mappings":"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"}