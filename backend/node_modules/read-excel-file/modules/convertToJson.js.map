{"version":3,"sources":["../source/convertToJson.js"],"names":["parseDate","Integer","isInteger","URL","isURL","Email","isEmail","DEFAULT_OPTIONS","isColumnOriented","data","schema","options","rowMap","validateSchema","transpose","columns","results","errors","i","length","result","read","push","error","row","rows","rowIndex","object","key","schemaEntry","isNestedSchema","type","Array","isArray","rawValue","indexOf","undefined","value","notEmpty","array","parseArray","map","_value","parseValue","required","column","prop","Object","keys","parse","parseCustomValue","parseValueOfType","oneOf","validate","message","String","Number","isFinite","parseFloat","Date","parseInt","date","properties","Boolean","Error","name","getBlock","string","endCharacter","startIndex","substring","character","block","blocks","index","trim","_","entry"],"mappings":"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","file":"convertToJson.js","sourcesContent":["import parseDate from './parseDate'\r\nimport Integer, { isInteger } from './types/Integer'\r\nimport URL, { isURL } from './types/URL'\r\nimport Email, { isEmail } from './types/Email'\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  isColumnOriented: false\r\n}\r\n\r\n/**\r\n * Convert 2D array to nested objects.\r\n * If row oriented data, row 0 is dotted key names.\r\n * Column oriented data is transposed.\r\n * @param {string[][]} data - An array of rows, each row being an array of cells.\r\n * @param {object} schema\r\n * @return {object[]}\r\n */\r\nexport default function(data, schema, options) {\r\n  if (options) {\r\n    options = {\r\n      ...DEFAULT_OPTIONS,\r\n      ...options\r\n    }\r\n  } else {\r\n    options = DEFAULT_OPTIONS\r\n  }\r\n\r\n  const {\r\n    isColumnOriented,\r\n    rowMap\r\n  } = options\r\n\r\n  validateSchema(schema)\r\n\r\n  if (isColumnOriented) {\r\n    data = transpose(data)\r\n  }\r\n\r\n  const columns = data[0]\r\n\r\n  const results = []\r\n  const errors = []\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    const result = read(schema, data[i], i - 1, columns, errors, options)\r\n    if (result) {\r\n      results.push(result)\r\n    }\r\n  }\r\n\r\n  // Correct error rows.\r\n  if (rowMap) {\r\n    for (const error of errors) {\r\n      // Convert the `row` index in `data` to the\r\n      // actual `row` index in the spreadsheet.\r\n      // The `1` compensates for the header row.\r\n      error.row = rowMap[error.row] + 1\r\n    }\r\n  }\r\n\r\n  return {\r\n    rows: results,\r\n    errors\r\n  }\r\n}\r\n\r\nfunction read(schema, row, rowIndex, columns, errors, options) {\r\n  const object = {}\r\n  for (const key of Object.keys(schema)) {\r\n    const schemaEntry = schema[key]\r\n    const isNestedSchema = typeof schemaEntry.type === 'object' && !Array.isArray(schemaEntry.type)\r\n    let rawValue = row[columns.indexOf(key)]\r\n    if (rawValue === undefined) {\r\n      rawValue = null\r\n    }\r\n    let value\r\n    let error\r\n    if (isNestedSchema) {\r\n      value = read(schemaEntry.type, row, rowIndex, columns, errors, options)\r\n    } else {\r\n      if (rawValue === null) {\r\n        value = null\r\n      }\r\n      else if (Array.isArray(schemaEntry.type)) {\r\n        let notEmpty = false\r\n        const array = parseArray(rawValue).map((_value) => {\r\n          const result = parseValue(_value, schemaEntry, options)\r\n          if (result.error) {\r\n            value = _value\r\n            error = result.error\r\n          }\r\n          if (result.value !== null) {\r\n            notEmpty = true\r\n          }\r\n          return result.value\r\n        })\r\n        if (!error) {\r\n          value = notEmpty ? array : null\r\n        }\r\n      } else {\r\n        const result = parseValue(rawValue, schemaEntry, options)\r\n        error = result.error\r\n        value = error ? rawValue : result.value\r\n      }\r\n    }\r\n    if (!error && value === null && schemaEntry.required) {\r\n      error = 'required'\r\n    }\r\n    if (error) {\r\n      error = {\r\n        error,\r\n        row: rowIndex + 1,\r\n        column: key,\r\n        value\r\n      }\r\n      if (schemaEntry.type) {\r\n        error.type = schemaEntry.type\r\n      }\r\n      errors.push(error)\r\n    } else if (value !== null) {\r\n      object[schemaEntry.prop] = value\r\n    }\r\n  }\r\n  if (Object.keys(object).length > 0) {\r\n    return object\r\n  }\r\n  return null\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {string} value\r\n * @param  {object} schemaEntry\r\n * @return {{ value: any, error: string }}\r\n */\r\nexport function parseValue(value, schemaEntry, options) {\r\n  if (value === null) {\r\n    return { value: null }\r\n  }\r\n  let result\r\n  if (schemaEntry.parse) {\r\n    result = parseCustomValue(value, schemaEntry.parse)\r\n  } else if (schemaEntry.type) {\r\n    result = parseValueOfType(value, Array.isArray(schemaEntry.type) ? schemaEntry.type[0] : schemaEntry.type, options)\r\n  } else {\r\n    result = { value: value }\r\n    // throw new Error('Invalid schema entry: no .type and no .parse():\\n\\n' + JSON.stringify(schemaEntry, null, 2))\r\n  }\r\n  // If errored then return the error.\r\n  if (result.error) {\r\n    return result\r\n  }\r\n  if (result.value !== null) {\r\n    if (schemaEntry.oneOf && schemaEntry.oneOf.indexOf(result.value) < 0) {\r\n      return { error: 'invalid' }\r\n    }\r\n    if (schemaEntry.validate) {\r\n      try {\r\n        schemaEntry.validate(result.value)\r\n      } catch (error) {\r\n        return { error: error.message }\r\n      }\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * Converts textual value to a custom value using supplied `.parse()`.\r\n * @param  {string} value\r\n * @param  {function} parse\r\n * @return {{ value: any, error: string }}\r\n */\r\nfunction parseCustomValue(value, parse) {\r\n  try {\r\n    value = parse(value)\r\n    if (value === undefined) {\r\n      return { value: null }\r\n    }\r\n    return { value }\r\n  } catch (error) {\r\n    return { error: error.message }\r\n  }\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {string} value\r\n * @param  {} type\r\n * @return {{ value: (string|number|Date|boolean), error: string }}\r\n */\r\nfunction parseValueOfType(value, type, options) {\r\n  switch (type) {\r\n    case String:\r\n      return { value }\r\n\r\n    case Number:\r\n    case Integer:\r\n      // The global isFinite() function determines\r\n      // whether the passed value is a finite number.\r\n      // If  needed, the parameter is first converted to a number.\r\n      if (!isFinite(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      if (type === Integer && !isInteger(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      // Convert strings to numbers.\r\n      // Just an additional feature.\r\n      // Won't happen when called from `readXlsx()`.\r\n      if (typeof value === 'string') {\r\n        value = parseFloat(value)\r\n      }\r\n      return { value }\r\n\r\n    case URL:\r\n      if (!isURL(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      return { value }\r\n\r\n    case Email:\r\n      if (!isEmail(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      return { value }\r\n\r\n    case Date:\r\n      // XLSX has no specific format for dates.\r\n      // Sometimes a date can be heuristically detected.\r\n      // https://github.com/catamphetamine/read-excel-file/issues/3#issuecomment-395770777\r\n      if (value instanceof Date) {\r\n        return { value }\r\n      }\r\n      if (typeof value === 'number') {\r\n        if (!isFinite(value)) {\r\n          return { error: 'invalid' }\r\n        }\r\n        value = parseInt(value)\r\n        const date = parseDate(value, options.properties)\r\n        if (!date) {\r\n          return { error: 'invalid' }\r\n        }\r\n        return { value: date }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    case Boolean:\r\n      if (typeof value === 'boolean') {\r\n        return { value }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    default:\r\n      if (typeof type === 'function') {\r\n        return parseCustomValue(value, type)\r\n      }\r\n      throw new Error(`Unknown schema type: ${type && type.name || type}`)\r\n  }\r\n}\r\n\r\nexport function getBlock(string, endCharacter, startIndex) {\r\n  let i = 0\r\n  let substring = ''\r\n  let character\r\n  while (startIndex + i < string.length) {\r\n    const character = string[startIndex + i]\r\n    if (character === endCharacter) {\r\n      return [substring, i]\r\n    }\r\n    else if (character === '\"') {\r\n      const block = getBlock(string, '\"', startIndex + i + 1)\r\n      substring += block[0]\r\n      i += '\"'.length + block[1] + '\"'.length\r\n    }\r\n    else {\r\n      substring += character\r\n      i++\r\n    }\r\n  }\r\n  return [substring, i]\r\n}\r\n\r\nexport function parseArray(string) {\r\n  const blocks = []\r\n  let index = 0\r\n  while (index < string.length) {\r\n    const [substring, length] = getBlock(string, ',', index)\r\n    index += length + ','.length\r\n    blocks.push(substring.trim())\r\n  }\r\n  return blocks\r\n}\r\n\r\n// Transpose a 2D array.\r\n// https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript\r\nconst transpose = array => array[0].map((_, i) => array.map(row => row[i]))\r\n\r\nfunction validateSchema(schema) {\r\n  for (const key of Object.keys(schema)) {\r\n    const entry = schema[key]\r\n    if (!entry.prop) {\r\n      throw new Error(`\"prop\" not defined for schema entry \"${key}\".`)\r\n    }\r\n  }\r\n}"]}