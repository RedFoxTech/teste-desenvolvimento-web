{"version":3,"sources":["../source/unpackXlsxFileNode.js"],"names":["fs","Stream","unzip","unpackXlsxFile","input","entries","stream","createReadStream","Promise","resolve","reject","entryPromises","on","pipe","Parse","all","then","entry","contents","push","data","toString","path"],"mappings":"AAAA,OAAOA,EAAP,MAAe,IAAf;AACA,OAAOC,MAAP,MAAmB,QAAnB;AACA,OAAOC,KAAP,MAAkB,UAAlB;;AAEA;;;;;AAKA,eAAe,SAASC,cAAT,CAAwBC,KAAxB,EAA+B;AAC5C;AACA;AACA;AACA,MAAMC,UAAU,EAAhB;;AAEA,MAAMC,SAASF,iBAAiBH,MAAjB,GAA0BG,KAA1B,GAAkCJ,GAAGO,gBAAH,CAAoBH,KAApB,CAAjD;;AAEA,SAAO,IAAII,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,QAAMC,gBAAgB,EAAtB;;AAEAL;AACE;AADF,KAEGM,EAFH,CAEM,OAFN,EAEeF,MAFf,EAGGG,IAHH,CAGQX,MAAMY,KAAN,EAHR;AAIE;AAJF,KAKGF,EALH,CAKM,OALN,EAKeF,MALf,EAMGE,EANH,CAMM,OANN,EAMe;AAAA,aAAOJ,QAAQO,GAAR,CAAYJ,aAAZ,EAA2BK,IAA3B,CAAgC;AAAA,eAAMP,QAAQJ,OAAR,CAAN;AAAA,OAAhC,CAAP;AAAA,KANf,EAOGO,EAPH,CAOM,OAPN,EAOe,UAACK,KAAD,EAAW;AACtB,UAAIC,WAAW,EAAf;AACA;AACAP,oBAAcQ,IAAd,CAAmB,IAAIX,OAAJ,CAAY,UAACC,OAAD,EAAa;AAC1CQ,cACGL,EADH,CACM,MADN,EACc;AAAA,iBAAQM,YAAYE,KAAKC,QAAL,EAApB;AAAA,SADd,EAEGT,EAFH,CAEM,KAFN,EAEa;AAAA,iBAAMH,QAAQJ,QAAQY,MAAMK,IAAd,IAAsBJ,QAA9B,CAAN;AAAA,SAFb;AAGD,OAJkB,CAAnB;AAKD,KAfH;AAgBD,GAnBM,CAAP;AAoBD","file":"unpackXlsxFileNode.js","sourcesContent":["import fs from 'fs'\r\nimport Stream from 'stream'\r\nimport unzip from 'unzipper'\r\n\r\n/**\r\n * Reads XLSX file in Node.js.\r\n * @param  {(string|Stream)} input - A Node.js readable stream or a path to a file.\r\n * @return {Promise} Resolves to an object holding XLSX file entries.\r\n */\r\nexport default function unpackXlsxFile(input) {\r\n  // XLSX file is a zip archive.\r\n  // The `entries` object stores the files\r\n  // and their contents from this XLSX zip archive.\r\n  const entries = {}\r\n\r\n  const stream = input instanceof Stream ? input : fs.createReadStream(input)\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const entryPromises = []\r\n\r\n    stream\r\n      // This first \"error\" listener is for the original stream errors.\r\n      .on('error', reject)\r\n      .pipe(unzip.Parse())\r\n      // This second \"error\" listener is for the unzip stream errors.\r\n      .on('error', reject)\r\n      .on('close', () =>  Promise.all(entryPromises).then(() => resolve(entries)))\r\n      .on('entry', (entry) => {\r\n        let contents = ''\r\n        // To ignore an entry: `entry.autodrain()`.\r\n        entryPromises.push(new Promise((resolve) => {\r\n          entry\r\n            .on('data', data => contents += data.toString())\r\n            .on('end', () => resolve(entries[entry.path] = contents))\r\n        }))\r\n      })\r\n  })\r\n}\r\n"]}